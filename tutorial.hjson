{
	"code_raw": 
		'''
		// @errors: 2300
		type Node = {board: Array<number>};
		type Heuristic = number;
		type IdealMove = {value: Heuristic, state: Node | null}

		function heuristic(): Heuristic {
			return 0;
		}

		function moves(node: Node): Array<Node> {
			return []
		}

		function gameOver(node: Node): boolean {
			return Math.random() > 0.5 ? true : false;
		}

		// ---cut---
		function minimax(node: Node, depth: number, maximizingPlayer: boolean): IdealMove {
			if (depth === 0 || gameOver(node)) {
				return {value: heuristic(), state: node};
			}
		 
			if (maximizingPlayer) {
				let value = -Infinity;
				let state = null;
				for (const child of moves(node)) {
					const {value: newValue, state: newState} = minimax(child, depth - 1, false);
					state = value > newValue ? state : newState
					value = Math.max(value, newValue)
				}
				return {value, state};
			} else {
				let value = Infinity;
				let state = null;
				for (const child of moves(node)) {
					const {value: newValue, state: newState} = minimax(child, depth - 1, false);
					state = value < newValue ? state : newState
					value = Math.min(value, newValue)
				}
				return {value, state};
			}
		}
		'''
	"first_block": [2, 3, 4, 5]
	"if_block": [6, 15, 24]
	"maximizing_block": [7, 8, 9, 10, 11, 12, 13, 14]
	"minimizing_block": [16, 17, 18, 19, 20, 21, 22, 23]

	"instructions": [
		"Today, we implement a lil minimax function"
		[
			"First, we need to check if the game is over or is out of bounds"
			"push 1 first_block"
			"focus 2"
			"focus* 2 3 4 5 6 7 8 9 10 11"
		]
		[
			"If then, we return the state of the board. This will help in recursion."
			"defocus"
			"focus 3"
		]
		[
			"From here, we have to do different things depending on whether we are choosing the best move (for the maximizingPlayer) or the worst (best for the opponent)"
			"defocus"
			"push 5 if_block"
		]
		[
			"As you can see, the maximizingPlayer argument is passed into the function. This is flipped whenever the function calls itself recursively so that we alternate correctly between moves good for us and moves good for the opponent"
			"focus 1 6"
			"focus* 1 13 14 15"
			"focus* 6 4"
		]
		[
			"If we are maximizing, we recursively find the best possible move and then return the heuristic for that..."
			"defocus"
			"push 6 maximizing_block"
		]
		[
			"...and vice versa"
			"push 15 minimizing_block"
		]
	]
}
